(
    history:[
        (
            context:[
            ],
            auto_run:true,
            model:"gemini 2.5 pro",
            project:"makepad-experiment-ai-one",
            base_context:"Makepad Game",
            last_time:1746183987.70117,
            messages:[
                User((
                    message:"Please use data1 in DrawBlock to fade out with the length of the tail ",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        \n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn pixel(self)->vec4{\n                let fade_factor = self.data1;\n                return mix(#33ff33, #33aa00, fade_factor);\n            }\n        }\n        draw_head:{\n            fn pixel(self)->vec4{\n                return #66ffff;\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n            fn pixel(self) -> vec4 {\n                return #ffff00;\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n\n        self.rng_state = Instant::now().duration_since(Instant::now()).as_nanos() as u64;\n        \n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                // Index 0 is head, len-1 is tail tip. We want fade near 1 for tail.\n                                // Index 1 (first body part) should have low fade, index len-1 high fade.\n                                if index > 0 { // Don't fade the head (it's drawn separately)\n                                    fade_factor = (index - 1) as f32 / (snake_len - 2) as f32;\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0); // Clamp to [0, 1]\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::KeyDown(ke) => {\n                if self.game_over && ke.key_code == KeyCode::Space {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1); \n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"the snake isnt moving anymore please fix",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn pixel(self)->vec4{\n                let fade_factor = self.data1;\n                return mix(#33ff33, #33aa00, fade_factor);\n            }\n        }\n        draw_head:{\n            fn pixel(self)->vec4{\n                return #66ffff;\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n            fn pixel(self) -> vec4 {\n                return #ffff00;\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please make the snake drawn using little circles in the pixelshader with a nice gradient over the data1 length",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let color1 = #33ff33;\n                let color2 = #33aa00;\n                let dist = self.sdf_circle(self.pos, 0.45);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                let final_color = mix(color1, color2, self.data1);\n                return vec4(final_color.rgb, alpha);\n            }\n        }\n        draw_head:{\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n           fn pixel(self)->vec4{\n                let color = #66ffff;\n                let dist = self.sdf_circle(self.pos, 0.48);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n            fn pixel(self) -> vec4 {\n                let color = #ffff00;\n                let dist = self.sdf_circle(self.pos, 0.4);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Make the head of the snake also a circle, and give the circles in the body a transparent edge not a green one",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let color1 = #33ff33;\n                let color2 = #33aa00;\n                let dist = self.sdf_circle(self.pos, 0.45);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                let final_color = mix(color1, color2, self.data1);\n                return vec4(final_color.rgb, alpha);\n            }\n        }\n        draw_head:{\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n           fn pixel(self)->vec4{\n                let color = #66ffff;\n                let dist = self.sdf_circle(self.pos, 0.48);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n            fn pixel(self) -> vec4 {\n                let color = #ffff00;\n                let dist = self.sdf_circle(self.pos, 0.4);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Make the snake automatically go to the food",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let color1 = #33ff33;\n                let color2 = #33aa00;\n                let dist = self.sdf_circle(self.pos, 0.45);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                let final_color = mix(color1, color2, self.data1);\n                return vec4(final_color.rgb, alpha);\n            }\n        }\n        draw_head:{\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n           fn pixel(self)->vec4{\n                let color = #66ffff;\n                let dist = self.sdf_circle(self.pos, 0.48);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n            fn pixel(self) -> vec4 {\n                let color = #ffff00;\n                let dist = self.sdf_circle(self.pos, 0.4);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             // If no path to food, try to keep moving in a valid direction that isn't reversing\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n             // If truly trapped, keep current direction (will likely crash next tick)\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"The circles are now still solid on the outside, could you make draw the circles do fake 3D nice and shiny phong like  and also make them nice and bright, also draw a smiley on the snakes head",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n            let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n            let diffuse = diffuse_intensity * albedo;\n            \n            let reflect_dir = reflect(-light_dir, normal);\n            let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n            let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n            \n            let final_color = ambient + diffuse + specular;\n            return final_color;\n        }\n\n        fn sdf_circle(self, p: vec2, radius: float) -> float {\n            return length(p - vec2(0.5, 0.5)) - radius;\n        }\n\n        fn circle_normal(self, p: vec2) -> vec3 {\n            let dist = self.sdf_circle(p, 0.48);\n            let grad_x = self.sdf_circle(p + vec2(0.001, 0.0), 0.48) - dist;\n            let grad_y = self.sdf_circle(p + vec2(0.0, 0.001), 0.48) - dist;\n            let n2 = normalize(vec2(grad_x, grad_y));\n            let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n            return vec3(n2.x, n2.y, z);\n        }\n\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        \n        draw_snake:{\n           \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let radius = 0.45;\n                let dist = self.sdf_circle(p, radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    discard;\n                }\n\n                let normal = self.circle_normal(p);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let light_dir = normalize(vec3(0.5, 0.5, 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let radius = 0.48;\n                let dist = self.sdf_circle(p, radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    discard;\n                }\n\n                let normal = self.circle_normal(p);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let light_dir = normalize(vec3(0.5, 0.5, 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = length(p - eye1_pos) - eye_radius;\n                let eye_dist2 = length(p - eye2_pos) - eye_radius;\n                \n                let smile_dist = self.sdf_line(p, vec2(0.3, 0.65), vec2(0.7, 0.65));\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                let radius = 0.4;\n                let dist = self.sdf_circle(p, radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    discard;\n                }\n\n                let normal = self.circle_normal(p);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let light_dir = normalize(vec3(0.5, 0.5, 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Don't call , and also functions for the shaders need to be defined in the draw_food:{} blocks not higher up. Also please draw nice phong rounded corner boxes and make the light rotate with the length of the snake, also discard is not available please return #0000 transparent color instead of discarding",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let q = abs(p - vec2(0.5, 0.5)) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.45, 0.45);\n                let corner_radius = 0.1;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let q = abs(p - vec2(0.5, 0.5)) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let q = abs(p - vec2(0.5, 0.5)) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Great! Lets draw a nice plasma in the background of the snake, and also the rounded boxes are now sharp at the top, could you make it nice and round at the top",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_value(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x + self.time) * 2.0);\n                v = v + sin((p.y + self.time * 0.5) * 3.0);\n                v = v + sin((p.x + p.y + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.0 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 10.0;\n                let val = self.plasma_value(p);\n                let color = vec3(\n                    0.5 + 0.5 * sin(PI * val),\n                    0.5 + 0.5 * sin(PI * val + 2.0 * PI / 3.0),\n                    0.5 + 0.5 * sin(PI * val + 4.0 * PI / 3.0)\n                );\n                return vec4(color * 0.3, 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.45, 0.45);\n                let corner_radius = 0.1;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        let current_time = Instant::now().duration_since(self.last_food_place_time).as_secs_f32();\n        self.draw_snake.apply_over(cx, live!{time: (current_time)});\n        self.draw_head.apply_over(cx, live!{time: (current_time)});\n        self.draw_food.apply_over(cx, live!{time: (current_time)});\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"You dont need to set 'time' its always available, also please make the plasma use a pastel colors and make it use embossing from a light vector, just a simple dot product on a heightmap",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x + self.time) * 2.0);\n                v = v + sin((p.y + self.time * 0.5) * 3.0);\n                v = v + sin((p.x + p.y + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.0 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.01; \n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 10.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.7, 0.5));\n                let emboss_factor = dot(normal, light_dir) * 0.5 + 0.5;\n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * emboss_factor * 0.6; \n                \n                return vec4(final_color, 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001; \n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 \n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.45, 0.45);\n                let corner_radius = 0.1;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 \n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 \n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Instead of rounded cubes could you make the snake draw a cylinder, but you pass in how the cylinder needs to be drawn using data1 (the rotation of it) also make the background really bumpmapped",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let capsule_radius = 0.25;\n                let half_length = 0.20; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data1 * 3.14159265 * 2.0; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, capsule_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, capsule_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0; // Default horizontal\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                    \n                                    let next_pos = self.snake_body.get(index - 1).unwrap_or(&self.snake_head); \n                                    let dx = next_pos.0 as f32 - x as f32;\n                                    let dy = next_pos.1 as f32 - y as f32;\n                                    segment_angle_rad = dy.atan2(dx);\n                                } else {\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Almost good except the rotation isnt correct, its only correct when going horizontally to the right",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let capsule_radius = 0.25;\n                let half_length = 0.20; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, capsule_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, capsule_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                    \n                                    let next_pos = self.snake_body.get(index - 1).unwrap_or(&self.snake_head); \n                                    let dx = next_pos.0 as f32 - x as f32;\n                                    let dy = next_pos.1 as f32 - y as f32;\n                                    segment_angle_rad = dy.atan2(dx);\n                                } else {\n                                     if snake_len > 1 {\n                                        let next_pos = self.snake_body.get(1).unwrap_or(&self.snake_head);\n                                        let dx = next_pos.0 as f32 - x as f32;\n                                        let dy = next_pos.1 as f32 - y as f32;\n                                        segment_angle_rad = dy.atan2(dx);\n                                    }\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Good work! Now please make sure that the rotation at the corners of the snake are also 45 degrees diagonal correctly",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let capsule_radius = 0.25;\n                let half_length = 0.20; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, capsule_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, capsule_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n    \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n\n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                             if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                             }\n\n                             let next_pos = if index > 0 {\n                                 self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                             } else {\n                                &self.snake_head // Should not happen for Field::Snake\n                             };\n                             \n                             let current_pos = (x, y);\n\n                             let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                             let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                             let angle_out = dy_out.atan2(dx_out);\n\n                             if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                             } else {\n                                segment_angle_rad = angle_out;\n                             }\n                        }\n                        \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"The capsules of the snake are very sharp in the middle, could you make them nice round tubes so they also connect correctly visually?",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n             fn sdf_rounded_tube(self, p: vec2, a: vec2, b: vec2, r: float) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let baba = dot(ba, ba);\n                let paba = dot(pa, ba);\n\n                let x = length(pa * baba - ba * paba) - r * baba;\n                let y = abs(paba - baba * 0.5) - baba * 0.5;\n\n                let x2 = x * x;\n                let y2 = y * y * baba;\n\n                let f = max(x, y);\n                let dist = if f < 0.0 {\n                     -min(x2, y2)\n                } else {\n                    if x > 0.0 { x2 } else { 0.0 } +\n                    if y > 0.0 { y2 } else { 0.0 }\n                };\n                return sign(dist) * sqrt(abs(dist)) / baba;\n             }\n\n             fn tube_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_tube(p, a, b, r);\n                 let grad_x = self.sdf_rounded_tube(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                 let grad_y = self.sdf_rounded_tube(p + vec2(0.0, epsilon), a, b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let tube_radius = 0.25;\n                let half_length = 0.25; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_rounded_tube(p, a, b, tube_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.tube_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n    \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n\n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                             if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                             }\n\n                             let next_pos = if index > 0 {\n                                 self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                             } else {\n                                &self.snake_head\n                             };\n                             \n                             let current_pos = (x, y);\n\n                             let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                             let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                             let angle_out = dy_out.atan2(dx_out);\n\n                             if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                             } else {\n                                segment_angle_rad = angle_out;\n                             }\n                        }\n                        \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"I don't see the tubes at all now, please retry",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001; // Adjusted epsilon\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let tube_radius = 0.4; // Made the tube thicker\n                let half_length = 0.5 - tube_radius; // Ensure ends connect within the cell\n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                // Calculate endpoints slightly shorter than the cell diagonal\n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n    \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n\n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                             if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                             }\n\n                             let next_pos = if index > 0 {\n                                 self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                             } else {\n                                &self.snake_head\n                             };\n                             \n                             let current_pos = (x, y);\n\n                             let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                             let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                             let angle_out = dy_out.atan2(dx_out);\n\n                             if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                             } else {\n                                segment_angle_rad = angle_out;\n                             }\n                        }\n                        \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"The blocks arent tubes that are connected at the edges, they have round edges now. Please try to make a tube in the shader that gets cut off at the edges so the snake connects properly. Also could you animate the background when the snake gets a piece of food so it crinkles the shapes/flashes a bit?",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n\n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                let flash_freq = 1.0 + self.food_eaten_factor * 20.0;\n                let flash_amp = self.food_eaten_factor * 0.2;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0 * flash_freq);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0 * flash_freq);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0 * flash_freq);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2 * flash_freq);\n                return v / 4.0 + flash_amp * sin(self.time * 50.0);\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.5;\n                let final_color = base_color * (0.3 + bump_factor * 1.5 + flash_brightness) ;\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001; \n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4; \n                let half_length = 0.5; \n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.5;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n                \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = std::time::SystemTime::now()\n        .duration_since(std.time::UNIX_EPOCH)\n        .unwrap_or_default()\n        .as_nanos() as u64;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs(1); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        let time_since_food = Instant::now().duration_since(self.last_food_eaten_time).as_secs_f32();\n        let food_eaten_factor = (1.0 - time_since_food / FLASH_DURATION).max(0.0);\n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"please just reset the rng state to 0 since that code doesnt work now. Also make the flash smoother its a bit jagged now, see if you can use a floating point counter",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                let deform = 1.0 + self.food_eaten_factor * 0.5;\n                let time_scale = 1.0 + self.food_eaten_factor * 1.0;\n                v = v + sin((p.x * 1.5 * deform + self.time * time_scale) * 2.0);\n                v = v + sin((p.y * 1.0 * deform + self.time * 0.5 * time_scale) * 3.0);\n                v = v + sin((p.x * 0.8 * deform + p.y * 1.2 * deform + self.time * 0.8 * time_scale) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 * deform + self.time * 1.2 * time_scale);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5; \n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_counter: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_counter = FLASH_DURATION;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        if self.food_eaten_counter > 0.0 {\n             self.food_eaten_counter -= 0.1; // Assuming 0.1s tick interval\n        } else {\n            self.food_eaten_counter = 0.0;\n        }\n\n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_counter = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        let time_since_food = Instant::now().duration_since(self.last_food_eaten_time).as_secs_f32();\n        let eased_factor = (1.0 - time_since_food / FLASH_DURATION).max(0.0);\n        let food_eaten_factor = eased_factor * eased_factor;\n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"The flash now zooms the noise pattern from the top left, maybe just multiply the noise pattern without scalign it.Also right now the food-animation is running in the tick code, but please run the clock/animation it in the draw code so it animates a lot smoother",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5; \n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_counter: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_counter = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_counter = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_counter > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_counter = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n                self.redraw(cx);\n            }\n            else{\n                self.food_eaten_counter = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_counter]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please use cx.redraw_area_in_draw(self.draw_bg.area()); at the end of draw_walk to trigger redraw always",
                )),
                Assistant("```rust\nuse link::widgets::*;\nuse link::theme::*;\nuse link::shaders::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin"),
                User((
                    message:"",
                )),
            ],
        ),
        (
            context:[
            ],
            auto_run:true,
            model:"gemini 2.5 pro",
            project:"makepad-experiment-ai-one",
            base_context:"Makepad Game",
            last_time:1746184603.420917,
            messages:[
                User((
                    message:"Please use data1 in DrawBlock to fade out with the length of the tail ",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        \n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn pixel(self)->vec4{\n                let fade_factor = self.data1;\n                return mix(#33ff33, #33aa00, fade_factor);\n            }\n        }\n        draw_head:{\n            fn pixel(self)->vec4{\n                return #66ffff;\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n            fn pixel(self) -> vec4 {\n                return #ffff00;\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n\n        self.rng_state = Instant::now().duration_since(Instant::now()).as_nanos() as u64;\n        \n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                // Index 0 is head, len-1 is tail tip. We want fade near 1 for tail.\n                                // Index 1 (first body part) should have low fade, index len-1 high fade.\n                                if index > 0 { // Don't fade the head (it's drawn separately)\n                                    fade_factor = (index - 1) as f32 / (snake_len - 2) as f32;\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0); // Clamp to [0, 1]\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::KeyDown(ke) => {\n                if self.game_over && ke.key_code == KeyCode::Space {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1); \n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"the snake isnt moving anymore please fix",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn pixel(self)->vec4{\n                let fade_factor = self.data1;\n                return mix(#33ff33, #33aa00, fade_factor);\n            }\n        }\n        draw_head:{\n            fn pixel(self)->vec4{\n                return #66ffff;\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n            fn pixel(self) -> vec4 {\n                return #ffff00;\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please make the snake drawn using little circles in the pixelshader with a nice gradient over the data1 length",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let color1 = #33ff33;\n                let color2 = #33aa00;\n                let dist = self.sdf_circle(self.pos, 0.45);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                let final_color = mix(color1, color2, self.data1);\n                return vec4(final_color.rgb, alpha);\n            }\n        }\n        draw_head:{\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n           fn pixel(self)->vec4{\n                let color = #66ffff;\n                let dist = self.sdf_circle(self.pos, 0.48);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n            fn pixel(self) -> vec4 {\n                let color = #ffff00;\n                let dist = self.sdf_circle(self.pos, 0.4);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Make the head of the snake also a circle, and give the circles in the body a transparent edge not a green one",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let color1 = #33ff33;\n                let color2 = #33aa00;\n                let dist = self.sdf_circle(self.pos, 0.45);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                let final_color = mix(color1, color2, self.data1);\n                return vec4(final_color.rgb, alpha);\n            }\n        }\n        draw_head:{\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n           fn pixel(self)->vec4{\n                let color = #66ffff;\n                let dist = self.sdf_circle(self.pos, 0.48);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n            fn pixel(self) -> vec4 {\n                let color = #ffff00;\n                let dist = self.sdf_circle(self.pos, 0.4);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Make the snake automatically go to the food",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let color1 = #33ff33;\n                let color2 = #33aa00;\n                let dist = self.sdf_circle(self.pos, 0.45);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                let final_color = mix(color1, color2, self.data1);\n                return vec4(final_color.rgb, alpha);\n            }\n        }\n        draw_head:{\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n           fn pixel(self)->vec4{\n                let color = #66ffff;\n                let dist = self.sdf_circle(self.pos, 0.48);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n            fn pixel(self) -> vec4 {\n                let color = #ffff00;\n                let dist = self.sdf_circle(self.pos, 0.4);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             // If no path to food, try to keep moving in a valid direction that isn't reversing\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n             // If truly trapped, keep current direction (will likely crash next tick)\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"The circles are now still solid on the outside, could you make draw the circles do fake 3D nice and shiny phong like  and also make them nice and bright, also draw a smiley on the snakes head",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n            let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n            let diffuse = diffuse_intensity * albedo;\n            \n            let reflect_dir = reflect(-light_dir, normal);\n            let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n            let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n            \n            let final_color = ambient + diffuse + specular;\n            return final_color;\n        }\n\n        fn sdf_circle(self, p: vec2, radius: float) -> float {\n            return length(p - vec2(0.5, 0.5)) - radius;\n        }\n\n        fn circle_normal(self, p: vec2) -> vec3 {\n            let dist = self.sdf_circle(p, 0.48);\n            let grad_x = self.sdf_circle(p + vec2(0.001, 0.0), 0.48) - dist;\n            let grad_y = self.sdf_circle(p + vec2(0.0, 0.001), 0.48) - dist;\n            let n2 = normalize(vec2(grad_x, grad_y));\n            let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n            return vec3(n2.x, n2.y, z);\n        }\n\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        \n        draw_snake:{\n           \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let radius = 0.45;\n                let dist = self.sdf_circle(p, radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    discard;\n                }\n\n                let normal = self.circle_normal(p);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let light_dir = normalize(vec3(0.5, 0.5, 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let radius = 0.48;\n                let dist = self.sdf_circle(p, radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    discard;\n                }\n\n                let normal = self.circle_normal(p);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let light_dir = normalize(vec3(0.5, 0.5, 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = length(p - eye1_pos) - eye_radius;\n                let eye_dist2 = length(p - eye2_pos) - eye_radius;\n                \n                let smile_dist = self.sdf_line(p, vec2(0.3, 0.65), vec2(0.7, 0.65));\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                let radius = 0.4;\n                let dist = self.sdf_circle(p, radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    discard;\n                }\n\n                let normal = self.circle_normal(p);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let light_dir = normalize(vec3(0.5, 0.5, 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Don't call , and also functions for the shaders need to be defined in the draw_food:{} blocks not higher up. Also please draw nice phong rounded corner boxes and make the light rotate with the length of the snake, also discard is not available please return #0000 transparent color instead of discarding",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let q = abs(p - vec2(0.5, 0.5)) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.45, 0.45);\n                let corner_radius = 0.1;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let q = abs(p - vec2(0.5, 0.5)) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let q = abs(p - vec2(0.5, 0.5)) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Great! Lets draw a nice plasma in the background of the snake, and also the rounded boxes are now sharp at the top, could you make it nice and round at the top",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_value(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x + self.time) * 2.0);\n                v = v + sin((p.y + self.time * 0.5) * 3.0);\n                v = v + sin((p.x + p.y + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.0 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 10.0;\n                let val = self.plasma_value(p);\n                let color = vec3(\n                    0.5 + 0.5 * sin(PI * val),\n                    0.5 + 0.5 * sin(PI * val + 2.0 * PI / 3.0),\n                    0.5 + 0.5 * sin(PI * val + 4.0 * PI / 3.0)\n                );\n                return vec4(color * 0.3, 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.45, 0.45);\n                let corner_radius = 0.1;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        let current_time = Instant::now().duration_since(self.last_food_place_time).as_secs_f32();\n        self.draw_snake.apply_over(cx, live!{time: (current_time)});\n        self.draw_head.apply_over(cx, live!{time: (current_time)});\n        self.draw_food.apply_over(cx, live!{time: (current_time)});\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"You dont need to set 'time' its always available, also please make the plasma use a pastel colors and make it use embossing from a light vector, just a simple dot product on a heightmap",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x + self.time) * 2.0);\n                v = v + sin((p.y + self.time * 0.5) * 3.0);\n                v = v + sin((p.x + p.y + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.0 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.01; \n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 10.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.7, 0.5));\n                let emboss_factor = dot(normal, light_dir) * 0.5 + 0.5;\n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * emboss_factor * 0.6; \n                \n                return vec4(final_color, 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001; \n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 \n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.45, 0.45);\n                let corner_radius = 0.1;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 \n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 \n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Instead of rounded cubes could you make the snake draw a cylinder, but you pass in how the cylinder needs to be drawn using data1 (the rotation of it) also make the background really bumpmapped",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let capsule_radius = 0.25;\n                let half_length = 0.20; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data1 * 3.14159265 * 2.0; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, capsule_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, capsule_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0; // Default horizontal\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                    \n                                    let next_pos = self.snake_body.get(index - 1).unwrap_or(&self.snake_head); \n                                    let dx = next_pos.0 as f32 - x as f32;\n                                    let dy = next_pos.1 as f32 - y as f32;\n                                    segment_angle_rad = dy.atan2(dx);\n                                } else {\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Almost good except the rotation isnt correct, its only correct when going horizontally to the right",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let capsule_radius = 0.25;\n                let half_length = 0.20; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, capsule_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, capsule_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                    \n                                    let next_pos = self.snake_body.get(index - 1).unwrap_or(&self.snake_head); \n                                    let dx = next_pos.0 as f32 - x as f32;\n                                    let dy = next_pos.1 as f32 - y as f32;\n                                    segment_angle_rad = dy.atan2(dx);\n                                } else {\n                                     if snake_len > 1 {\n                                        let next_pos = self.snake_body.get(1).unwrap_or(&self.snake_head);\n                                        let dx = next_pos.0 as f32 - x as f32;\n                                        let dy = next_pos.1 as f32 - y as f32;\n                                        segment_angle_rad = dy.atan2(dx);\n                                    }\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Good work! Now please make sure that the rotation at the corners of the snake are also 45 degrees diagonal correctly",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let capsule_radius = 0.25;\n                let half_length = 0.20; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, capsule_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, capsule_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n    \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n\n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                             if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                             }\n\n                             let next_pos = if index > 0 {\n                                 self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                             } else {\n                                &self.snake_head // Should not happen for Field::Snake\n                             };\n                             \n                             let current_pos = (x, y);\n\n                             let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                             let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                             let angle_out = dy_out.atan2(dx_out);\n\n                             if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                             } else {\n                                segment_angle_rad = angle_out;\n                             }\n                        }\n                        \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"The capsules of the snake are very sharp in the middle, could you make them nice round tubes so they also connect correctly visually?",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n             fn sdf_rounded_tube(self, p: vec2, a: vec2, b: vec2, r: float) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let baba = dot(ba, ba);\n                let paba = dot(pa, ba);\n\n                let x = length(pa * baba - ba * paba) - r * baba;\n                let y = abs(paba - baba * 0.5) - baba * 0.5;\n\n                let x2 = x * x;\n                let y2 = y * y * baba;\n\n                let f = max(x, y);\n                let dist = if f < 0.0 {\n                     -min(x2, y2)\n                } else {\n                    if x > 0.0 { x2 } else { 0.0 } +\n                    if y > 0.0 { y2 } else { 0.0 }\n                };\n                return sign(dist) * sqrt(abs(dist)) / baba;\n             }\n\n             fn tube_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_tube(p, a, b, r);\n                 let grad_x = self.sdf_rounded_tube(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                 let grad_y = self.sdf_rounded_tube(p + vec2(0.0, epsilon), a, b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let tube_radius = 0.25;\n                let half_length = 0.25; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_rounded_tube(p, a, b, tube_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.tube_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n    \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n\n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                             if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                             }\n\n                             let next_pos = if index > 0 {\n                                 self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                             } else {\n                                &self.snake_head\n                             };\n                             \n                             let current_pos = (x, y);\n\n                             let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                             let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                             let angle_out = dy_out.atan2(dx_out);\n\n                             if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                             } else {\n                                segment_angle_rad = angle_out;\n                             }\n                        }\n                        \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"I don't see the tubes at all now, please retry",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001; // Adjusted epsilon\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let tube_radius = 0.4; // Made the tube thicker\n                let half_length = 0.5 - tube_radius; // Ensure ends connect within the cell\n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                // Calculate endpoints slightly shorter than the cell diagonal\n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n    \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n\n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                             if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                             }\n\n                             let next_pos = if index > 0 {\n                                 self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                             } else {\n                                &self.snake_head\n                             };\n                             \n                             let current_pos = (x, y);\n\n                             let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                             let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                             let angle_out = dy_out.atan2(dx_out);\n\n                             if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                             } else {\n                                segment_angle_rad = angle_out;\n                             }\n                        }\n                        \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"The blocks arent tubes that are connected at the edges, they have round edges now. Please try to make a tube in the shader that gets cut off at the edges so the snake connects properly. Also could you animate the background when the snake gets a piece of food so it crinkles the shapes/flashes a bit?",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n\n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                let flash_freq = 1.0 + self.food_eaten_factor * 20.0;\n                let flash_amp = self.food_eaten_factor * 0.2;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0 * flash_freq);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0 * flash_freq);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0 * flash_freq);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2 * flash_freq);\n                return v / 4.0 + flash_amp * sin(self.time * 50.0);\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.5;\n                let final_color = base_color * (0.3 + bump_factor * 1.5 + flash_brightness) ;\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001; \n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4; \n                let half_length = 0.5; \n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.5;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n                \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = std::time::SystemTime::now()\n        .duration_since(std.time::UNIX_EPOCH)\n        .unwrap_or_default()\n        .as_nanos() as u64;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs(1); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        let time_since_food = Instant::now().duration_since(self.last_food_eaten_time).as_secs_f32();\n        let food_eaten_factor = (1.0 - time_since_food / FLASH_DURATION).max(0.0);\n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"please just reset the rng state to 0 since that code doesnt work now. Also make the flash smoother its a bit jagged now, see if you can use a floating point counter",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                let deform = 1.0 + self.food_eaten_factor * 0.5;\n                let time_scale = 1.0 + self.food_eaten_factor * 1.0;\n                v = v + sin((p.x * 1.5 * deform + self.time * time_scale) * 2.0);\n                v = v + sin((p.y * 1.0 * deform + self.time * 0.5 * time_scale) * 3.0);\n                v = v + sin((p.x * 0.8 * deform + p.y * 1.2 * deform + self.time * 0.8 * time_scale) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 * deform + self.time * 1.2 * time_scale);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5; \n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_counter: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_counter = FLASH_DURATION;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        if self.food_eaten_counter > 0.0 {\n             self.food_eaten_counter -= 0.1; // Assuming 0.1s tick interval\n        } else {\n            self.food_eaten_counter = 0.0;\n        }\n\n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_counter = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        let time_since_food = Instant::now().duration_since(self.last_food_eaten_time).as_secs_f32();\n        let eased_factor = (1.0 - time_since_food / FLASH_DURATION).max(0.0);\n        let food_eaten_factor = eased_factor * eased_factor;\n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"The flash now zooms the noise pattern from the top left, maybe just multiply the noise pattern without scalign it.Also right now the food-animation is running in the tick code, but please run the clock/animation it in the draw code so it animates a lot smoother",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5; \n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_counter: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_counter = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_counter = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_counter > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_counter = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n                self.redraw(cx);\n            }\n            else{\n                self.food_eaten_counter = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_counter]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please use cx.redraw_area_in_draw(self.draw_bg.area()); at the end of draw_walk to trigger redraw always. Also the tubes are razor sharp and not nicely rounded, see if you can improve the distance field",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5 - tube_radius;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Now the segments of the snake in between are round again, as opposed to tubes and also the snake doesnt reset when it dies",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5 - tube_radius;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Could you make the background noise embossed with a lightsource moving around in circle",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                \n                let light_angle = self.time * 0.6;\n                let light_dir = normalize(vec3(cos(light_angle), sin(light_angle), 0.5));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let emboss_factor = diffuse * 0.6 + 0.4;\n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * emboss_factor * 0.7 + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please make the game restart automatically after the snake dies with a timeout of 2 seconds",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                \n                let light_angle = self.time * 0.6;\n                let light_dir = normalize(vec3(cos(light_angle), sin(light_angle), 0.5));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let emboss_factor = diffuse * 0.6 + 0.4;\n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * emboss_factor * 0.7 + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.1);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please draw a score counter label in the top left background and update this every time the snake eats food",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                \n                let light_angle = self.time * 0.6;\n                let light_dir = normalize(vec3(cos(light_angle), sin(light_angle), 0.5));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let emboss_factor = diffuse * 0.6 + 0.4;\n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * emboss_factor * 0.7 + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <Overlay>{\n                    show_bg: true,\n                    game = <SnakeGame>{}\n                    score_display = <Label>{\n                        abs_pos: vec2(20, 20),\n                        draw_text: {\n                            text_style: <H2>{font_size: 14},\n                            color: #fff\n                        },\n                        text: \"Score: 0\"\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust] score: u32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.score += 1;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        self.score = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.1);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n            let label = scope.get_label(id!(score_display));\n            label.set_text(&format!(\"Score: {}\", self.score));\n            label.redraw(cx);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            let label = scope.get_label(id!(score_display));\n            label.set_text(&format!(\"Score: {}\", self.score));\n            label.redraw(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    let label = scope.get_label(id!(score_display));\n                    label.set_text(&format!(\"Score: {}\", self.score));\n                    label.redraw(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        let mut scope = Scope::empty();\n        if let Event::Draw(event) = event {\n             let snake_game: Option<(&mut SnakeGame, LiveId)> = self.ui.get_widget(id!(game)).borrow_mut();\n             if let Some((snake_game, _)) = snake_game {\n                  let score = snake_game.score;\n                   let label = self.ui.get_label(id!(score_display));\n                   label.set_text(&format!(\"Score: {}\", score));\n             }\n             return self.ui.handle_event(cx, event, &mut scope);\n        }\n        self.ui.handle_event(cx, event, &mut scope);\n    }\n}\n\n```"),
                User((
                    message:"",
                )),
            ],
        ),
        (
            context:[
            ],
            auto_run:true,
            model:"gemini 2.5 pro",
            project:"makepad-experiment-ai-snake",
            base_context:"Makepad Game",
            last_time:1746216895.863527,
            messages:[
                User((
                    message:"Please use data1 in DrawBlock to fade out with the length of the tail ",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        \n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn pixel(self)->vec4{\n                let fade_factor = self.data1;\n                return mix(#33ff33, #33aa00, fade_factor);\n            }\n        }\n        draw_head:{\n            fn pixel(self)->vec4{\n                return #66ffff;\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n            fn pixel(self) -> vec4 {\n                return #ffff00;\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n\n        self.rng_state = Instant::now().duration_since(Instant::now()).as_nanos() as u64;\n        \n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                // Index 0 is head, len-1 is tail tip. We want fade near 1 for tail.\n                                // Index 1 (first body part) should have low fade, index len-1 high fade.\n                                if index > 0 { // Don't fade the head (it's drawn separately)\n                                    fade_factor = (index - 1) as f32 / (snake_len - 2) as f32;\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0); // Clamp to [0, 1]\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::KeyDown(ke) => {\n                if self.game_over && ke.key_code == KeyCode::Space {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1); \n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"the snake isnt moving anymore please fix",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn pixel(self)->vec4{\n                let fade_factor = self.data1;\n                return mix(#33ff33, #33aa00, fade_factor);\n            }\n        }\n        draw_head:{\n            fn pixel(self)->vec4{\n                return #66ffff;\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n            fn pixel(self) -> vec4 {\n                return #ffff00;\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please make the snake drawn using little circles in the pixelshader with a nice gradient over the data1 length",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let color1 = #33ff33;\n                let color2 = #33aa00;\n                let dist = self.sdf_circle(self.pos, 0.45);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                let final_color = mix(color1, color2, self.data1);\n                return vec4(final_color.rgb, alpha);\n            }\n        }\n        draw_head:{\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n           fn pixel(self)->vec4{\n                let color = #66ffff;\n                let dist = self.sdf_circle(self.pos, 0.48);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n            fn pixel(self) -> vec4 {\n                let color = #ffff00;\n                let dist = self.sdf_circle(self.pos, 0.4);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Make the head of the snake also a circle, and give the circles in the body a transparent edge not a green one",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let color1 = #33ff33;\n                let color2 = #33aa00;\n                let dist = self.sdf_circle(self.pos, 0.45);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                let final_color = mix(color1, color2, self.data1);\n                return vec4(final_color.rgb, alpha);\n            }\n        }\n        draw_head:{\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n           fn pixel(self)->vec4{\n                let color = #66ffff;\n                let dist = self.sdf_circle(self.pos, 0.48);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n            fn pixel(self) -> vec4 {\n                let color = #ffff00;\n                let dist = self.sdf_circle(self.pos, 0.4);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Make the snake automatically go to the food",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        draw_snake:{\n            fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let color1 = #33ff33;\n                let color2 = #33aa00;\n                let dist = self.sdf_circle(self.pos, 0.45);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                let final_color = mix(color1, color2, self.data1);\n                return vec4(final_color.rgb, alpha);\n            }\n        }\n        draw_head:{\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n           fn pixel(self)->vec4{\n                let color = #66ffff;\n                let dist = self.sdf_circle(self.pos, 0.48);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n             fn sdf_circle(self, pos: vec2, radius: float) -> float {\n                return length(pos - vec2(0.5, 0.5)) - radius;\n            }\n            fn pixel(self) -> vec4 {\n                let color = #ffff00;\n                let dist = self.sdf_circle(self.pos, 0.4);\n                let alpha = 1.0 - smoothstep(0.0, 0.02, dist);\n                return vec4(color.rgb, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             // If no path to food, try to keep moving in a valid direction that isn't reversing\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n             // If truly trapped, keep current direction (will likely crash next tick)\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"The circles are now still solid on the outside, could you make draw the circles do fake 3D nice and shiny phong like  and also make them nice and bright, also draw a smiley on the snakes head",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n            let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n            let diffuse = diffuse_intensity * albedo;\n            \n            let reflect_dir = reflect(-light_dir, normal);\n            let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n            let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n            \n            let final_color = ambient + diffuse + specular;\n            return final_color;\n        }\n\n        fn sdf_circle(self, p: vec2, radius: float) -> float {\n            return length(p - vec2(0.5, 0.5)) - radius;\n        }\n\n        fn circle_normal(self, p: vec2) -> vec3 {\n            let dist = self.sdf_circle(p, 0.48);\n            let grad_x = self.sdf_circle(p + vec2(0.001, 0.0), 0.48) - dist;\n            let grad_y = self.sdf_circle(p + vec2(0.0, 0.001), 0.48) - dist;\n            let n2 = normalize(vec2(grad_x, grad_y));\n            let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n            return vec3(n2.x, n2.y, z);\n        }\n\n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        \n        draw_snake:{\n           \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let radius = 0.45;\n                let dist = self.sdf_circle(p, radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    discard;\n                }\n\n                let normal = self.circle_normal(p);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let light_dir = normalize(vec3(0.5, 0.5, 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let radius = 0.48;\n                let dist = self.sdf_circle(p, radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    discard;\n                }\n\n                let normal = self.circle_normal(p);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let light_dir = normalize(vec3(0.5, 0.5, 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = length(p - eye1_pos) - eye_radius;\n                let eye_dist2 = length(p - eye2_pos) - eye_radius;\n                \n                let smile_dist = self.sdf_line(p, vec2(0.3, 0.65), vec2(0.7, 0.65));\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                let radius = 0.4;\n                let dist = self.sdf_circle(p, radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    discard;\n                }\n\n                let normal = self.circle_normal(p);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let light_dir = normalize(vec3(0.5, 0.5, 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n        \n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Don't call , and also functions for the shaders need to be defined in the draw_food:{} blocks not higher up. Also please draw nice phong rounded corner boxes and make the light rotate with the length of the snake, also discard is not available please return #0000 transparent color instead of discarding",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            fn pixel(self)->vec4{\n                return #113311;\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let q = abs(p - vec2(0.5, 0.5)) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.45, 0.45);\n                let corner_radius = 0.1;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let q = abs(p - vec2(0.5, 0.5)) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let q = abs(p - vec2(0.5, 0.5)) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Great! Lets draw a nice plasma in the background of the snake, and also the rounded boxes are now sharp at the top, could you make it nice and round at the top",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_value(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x + self.time) * 2.0);\n                v = v + sin((p.y + self.time * 0.5) * 3.0);\n                v = v + sin((p.x + p.y + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.0 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 10.0;\n                let val = self.plasma_value(p);\n                let color = vec3(\n                    0.5 + 0.5 * sin(PI * val),\n                    0.5 + 0.5 * sin(PI * val + 2.0 * PI / 3.0),\n                    0.5 + 0.5 * sin(PI * val + 4.0 * PI / 3.0)\n                );\n                return vec4(color * 0.3, 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.45, 0.45);\n                let corner_radius = 0.1;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return vec3(n2.x, n2.y, z);\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n        \n        let current_time = Instant::now().duration_since(self.last_food_place_time).as_secs_f32();\n        self.draw_snake.apply_over(cx, live!{time: (current_time)});\n        self.draw_head.apply_over(cx, live!{time: (current_time)});\n        self.draw_food.apply_over(cx, live!{time: (current_time)});\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"You dont need to set 'time' its always available, also please make the plasma use a pastel colors and make it use embossing from a light vector, just a simple dot product on a heightmap",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x + self.time) * 2.0);\n                v = v + sin((p.y + self.time * 0.5) * 3.0);\n                v = v + sin((p.x + p.y + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.0 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.01; \n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 10.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.7, 0.5));\n                let emboss_factor = dot(normal, light_dir) * 0.5 + 0.5;\n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * emboss_factor * 0.6; \n                \n                return vec4(final_color, 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001; \n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 \n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.45, 0.45);\n                let corner_radius = 0.1;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 \n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 \n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Instead of rounded cubes could you make the snake draw a cylinder, but you pass in how the cylinder needs to be drawn using data1 (the rotation of it) also make the background really bumpmapped",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let capsule_radius = 0.25;\n                let half_length = 0.20; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data1 * 3.14159265 * 2.0; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, capsule_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, capsule_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, self.data1);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0; // Default horizontal\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                    \n                                    let next_pos = self.snake_body.get(index - 1).unwrap_or(&self.snake_head); \n                                    let dx = next_pos.0 as f32 - x as f32;\n                                    let dy = next_pos.1 as f32 - y as f32;\n                                    segment_angle_rad = dy.atan2(dx);\n                                } else {\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"Almost good except the rotation isnt correct, its only correct when going horizontally to the right",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{}\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let capsule_radius = 0.25;\n                let half_length = 0.20; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, capsule_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, capsule_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        if snake_len > 1 {\n                            if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                                if index > 0 { \n                                    fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                                    \n                                    let next_pos = self.snake_body.get(index - 1).unwrap_or(&self.snake_head); \n                                    let dx = next_pos.0 as f32 - x as f32;\n                                    let dy = next_pos.1 as f32 - y as f32;\n                                    segment_angle_rad = dy.atan2(dx);\n                                } else {\n                                     if snake_len > 1 {\n                                        let next_pos = self.snake_body.get(1).unwrap_or(&self.snake_head);\n                                        let dx = next_pos.0 as f32 - x as f32;\n                                        let dy = next_pos.1 as f32 - y as f32;\n                                        segment_angle_rad = dy.atan2(dx);\n                                    }\n                                }\n                            }\n                        }\n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Good work! Now please make sure that the rotation at the corners of the snake are also 45 degrees diagonal correctly",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let capsule_radius = 0.25;\n                let half_length = 0.20; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, capsule_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, capsule_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n    \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n\n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                             if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                             }\n\n                             let next_pos = if index > 0 {\n                                 self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                             } else {\n                                &self.snake_head // Should not happen for Field::Snake\n                             };\n                             \n                             let current_pos = (x, y);\n\n                             let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                             let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                             let angle_out = dy_out.atan2(dx_out);\n\n                             if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                             } else {\n                                segment_angle_rad = angle_out;\n                             }\n                        }\n                        \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"The capsules of the snake are very sharp in the middle, could you make them nice round tubes so they also connect correctly visually?",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n             fn sdf_rounded_tube(self, p: vec2, a: vec2, b: vec2, r: float) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let baba = dot(ba, ba);\n                let paba = dot(pa, ba);\n\n                let x = length(pa * baba - ba * paba) - r * baba;\n                let y = abs(paba - baba * 0.5) - baba * 0.5;\n\n                let x2 = x * x;\n                let y2 = y * y * baba;\n\n                let f = max(x, y);\n                let dist = if f < 0.0 {\n                     -min(x2, y2)\n                } else {\n                    if x > 0.0 { x2 } else { 0.0 } +\n                    if y > 0.0 { y2 } else { 0.0 }\n                };\n                return sign(dist) * sqrt(abs(dist)) / baba;\n             }\n\n             fn tube_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_tube(p, a, b, r);\n                 let grad_x = self.sdf_rounded_tube(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                 let grad_y = self.sdf_rounded_tube(p + vec2(0.0, epsilon), a, b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let tube_radius = 0.25;\n                let half_length = 0.25; \n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_rounded_tube(p, a, b, tube_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.tube_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n    \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n\n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                             if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                             }\n\n                             let next_pos = if index > 0 {\n                                 self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                             } else {\n                                &self.snake_head\n                             };\n                             \n                             let current_pos = (x, y);\n\n                             let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                             let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                             let angle_out = dy_out.atan2(dx_out);\n\n                             if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                             } else {\n                                segment_angle_rad = angle_out;\n                             }\n                        }\n                        \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"I don't see the tubes at all now, please retry",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n    \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n    \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        \n        draw_bg:{\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n\n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n\n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                \n                let base_color = self.pastel_color(height);\n                let final_color = base_color * (0.3 + bump_factor * 1.5);\n                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n        \n        draw_snake:{\n            \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n\n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001; // Adjusted epsilon\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let tube_radius = 0.4; // Made the tube thicker\n                let half_length = 0.5 - tube_radius; // Ensure ends connect within the cell\n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                // Calculate endpoints slightly shorter than the cell diagonal\n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n\n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n\n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                return vec4(shaded_color, alpha);\n            }\n        }\n        \n        draw_head:{\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n\n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n\n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n\n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n\n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n\n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n\n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n\n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n\n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n\n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n        \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        \n        draw_food: {\n             fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n\n             fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                 let epsilon = 0.0001;\n                 let dist = self.sdf_rounded_box(p, b, r);\n                 let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                 let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                 let n2 = normalize(vec2(grad_x, grad_y));\n                 let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                 return normalize(vec3(n2.x, n2.y, z));\n             }\n             \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self) -> vec4 {\n                 let p = self.pos;\n                 let box_half_size = vec2(0.4, 0.4);\n                 let corner_radius = 0.2;\n                 let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                \n                 let alpha = smoothstep(0.02, 0.0, dist);\n                 if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                 }\n\n                 let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                 let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                 let angle = self.time * 0.5;\n                 let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                 let ambient = vec3(0.1, 0.1, 0.0);\n                 let specular_power = 32.0;\n                 let albedo = vec3(1.0, 1.0, 0.0);\n\n                 let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n\n                 return vec4(shaded_color, alpha);\n            }\n        }\n    }\n            \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n            \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n    \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n    \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n\n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n\n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n\n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n\n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n\n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                 if self.snake_body.len() > 1 { continue; }\n            }\n\n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n\n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n\n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n             self.snake_direction = best_move.0;\n         } else {\n             for dir in potential_dirs {\n                 if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                      if self.snake_body.len() > 1 { continue; }\n                 }\n                 let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                 let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                 let next_idx = next_y * grid_w + next_x;\n                  match self.field[next_idx] {\n                     Field::Empty | Field::Food => {\n                         self.snake_direction = dir;\n                         return;\n                     }\n                     _ => {}\n                 }\n             }\n         }\n    }\n    \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        self.determine_next_direction();\n                \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                \n        let next_idx = next_y * grid_w + next_x;\n                \n        let mut ate_food = false;\n        \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n        \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n        \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                \n        self.rng_state = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n\n        self.place_food(); \n                \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        \n    }\n    \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n\n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                \n        let snake_len = self.snake_body.len();\n\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                             if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                             }\n\n                             let next_pos = if index > 0 {\n                                 self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                             } else {\n                                &self.snake_head\n                             };\n                             \n                             let current_pos = (x, y);\n\n                             let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                             let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                             let angle_out = dy_out.atan2(dx_out);\n\n                             if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                             } else {\n                                segment_angle_rad = angle_out;\n                             }\n                        }\n                        \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n            \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                \n        match event{\n            Event::KeyDown(ke) => {\n                 if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                 }\n            }\n             _=>()\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"The blocks arent tubes that are connected at the edges, they have round edges now. Please try to make a tube in the shader that gets cut off at the edges so the snake connects properly. Also could you animate the background when the snake gets a piece of food so it crinkles the shapes/flashes a bit?",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n\n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                let flash_freq = 1.0 + self.food_eaten_factor * 20.0;\n                let flash_amp = self.food_eaten_factor * 0.2;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0 * flash_freq);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0 * flash_freq);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0 * flash_freq);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2 * flash_freq);\n                return v / 4.0 + flash_amp * sin(self.time * 50.0);\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.5;\n                let final_color = base_color * (0.3 + bump_factor * 1.5 + flash_brightness) ;\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001; \n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4; \n                let half_length = 0.5; \n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.5;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n                \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = std::time::SystemTime::now()\n        .duration_since(std.time::UNIX_EPOCH)\n        .unwrap_or_default()\n        .as_nanos() as u64;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs(1); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        let time_since_food = Instant::now().duration_since(self.last_food_eaten_time).as_secs_f32();\n        let food_eaten_factor = (1.0 - time_since_food / FLASH_DURATION).max(0.0);\n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"please just reset the rng state to 0 since that code doesnt work now. Also make the flash smoother its a bit jagged now, see if you can use a floating point counter",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                let deform = 1.0 + self.food_eaten_factor * 0.5;\n                let time_scale = 1.0 + self.food_eaten_factor * 1.0;\n                v = v + sin((p.x * 1.5 * deform + self.time * time_scale) * 2.0);\n                v = v + sin((p.y * 1.0 * deform + self.time * 0.5 * time_scale) * 3.0);\n                v = v + sin((p.x * 0.8 * deform + p.y * 1.2 * deform + self.time * 0.8 * time_scale) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 * deform + self.time * 1.2 * time_scale);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5; \n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_counter: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_counter = FLASH_DURATION;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        if self.food_eaten_counter > 0.0 {\n             self.food_eaten_counter -= 0.1; // Assuming 0.1s tick interval\n        } else {\n            self.food_eaten_counter = 0.0;\n        }\n\n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_counter = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        let time_since_food = Instant::now().duration_since(self.last_food_eaten_time).as_secs_f32();\n        let eased_factor = (1.0 - time_since_food / FLASH_DURATION).max(0.0);\n        let food_eaten_factor = eased_factor * eased_factor;\n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n```"),
                User((
                    message:"The flash now zooms the noise pattern from the top left, maybe just multiply the noise pattern without scalign it.Also right now the food-animation is running in the tick code, but please run the clock/animation it in the draw code so it animates a lot smoother",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5; \n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_counter: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_counter = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_counter = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_counter > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_counter = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n                self.redraw(cx);\n            }\n            else{\n                self.food_eaten_counter = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_counter]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please use cx.redraw_area_in_draw(self.draw_bg.area()); at the end of draw_walk to trigger redraw always. Also the tubes are razor sharp and not nicely rounded, see if you can improve the distance field",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5 - tube_radius;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Now the segments of the snake in between are round again, as opposed to tubes and also the snake doesnt reset when it dies",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let bump_factor = pow(diffuse, 4.0); \n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5 - tube_radius;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Could you make the background noise embossed with a lightsource moving around in circle",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                \n                let light_angle = self.time * 0.6;\n                let light_dir = normalize(vec3(cos(light_angle), sin(light_angle), 0.5));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let emboss_factor = diffuse * 0.6 + 0.4;\n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * emboss_factor * 0.7 + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please make the game restart automatically after the snake dies with a timeout of 2 seconds",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                \n                let light_angle = self.time * 0.6;\n                let light_dir = normalize(vec3(cos(light_angle), sin(light_angle), 0.5));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let emboss_factor = diffuse * 0.6 + 0.4;\n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * emboss_factor * 0.7 + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let tube_radius = 0.4;\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, tube_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.1);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please make the tail thinner at the end of the snake using the data1/2 values",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                \n                let light_angle = self.time * 0.6;\n                let light_dir = normalize(vec3(cos(light_angle), sin(light_angle), 0.5));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let emboss_factor = diffuse * 0.6 + 0.4;\n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * emboss_factor * 0.7 + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                \n                let max_radius = 0.4;\n                let min_radius = 0.1;\n                let fade_factor = self.data1;\n                let current_radius = mix(max_radius, min_radius, fade_factor);\n\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, current_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, current_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.1);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"The corners of the snake when it turns are now hard 45 degree edges, could you make the corners properly round quarter circles?",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                \n                let light_angle = self.time * 0.6;\n                let light_dir = normalize(vec3(cos(light_angle), sin(light_angle), 0.5));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let emboss_factor = diffuse * 0.6 + 0.4;\n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * emboss_factor * 0.7 + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let max_radius = 0.4;\n                let min_radius = 0.1;\n                let fade_factor = self.data1;\n                let current_radius = mix(max_radius, min_radius, fade_factor);\n\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, current_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, current_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.1);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"The corners are still straight, please make them round",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n            \n            fn plasma_height(self, p: vec2) -> float {\n                let v = 0.0;\n                v = v + sin((p.x * 1.5 + self.time) * 2.0);\n                v = v + sin((p.y * 1.0 + self.time * 0.5) * 3.0);\n                v = v + sin((p.x * 0.8 + p.y * 1.2 + self.time * 0.8) * 1.0);\n                v = v + sin(sqrt(p.x * p.x + p.y * p.y) * 2.5 + self.time * 1.2);\n                return v / 4.0;\n            }\n            \n            fn plasma_normal(self, p: vec2) -> vec3 {\n                let epsilon = 0.005;\n                let h = self.plasma_height(p);\n                let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n                let hy = self.plasma_height(p + vec2(0.0, epsilon));\n                let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n                return n;\n            }\n            \n            fn pastel_color(self, v: float) -> vec3 {\n                let pi = 3.1415926535;\n                let r = 0.8 + 0.2 * sin(pi * v);\n                let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n                let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n                return vec3(r, g, b);\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos * 8.0;\n                let height = self.plasma_height(p);\n                let normal = self.plasma_normal(p);\n                \n                let light_angle = self.time * 0.6;\n                let light_dir = normalize(vec3(cos(light_angle), sin(light_angle), 0.5));\n                                \n                let diffuse = max(0.0, dot(normal, light_dir));\n                let emboss_factor = diffuse * 0.6 + 0.4;\n                                \n                let base_color = self.pastel_color(height);\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = base_color * emboss_factor * 0.7 + vec3(flash_brightness);\n                                \n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let max_radius = 0.4;\n                let min_radius = 0.1;\n                let fade_factor = self.data1;\n                let current_radius = mix(max_radius, min_radius, fade_factor);\n\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, current_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, current_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n    #[live] data3: f32,\n    #[live] data4: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.1);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                        let mut angle_in = 0.0f32;\n                        let mut is_corner = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = angle_out; \n                                    is_corner = 1.0;\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                    angle_in = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                                angle_in = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.data3 = angle_in;\n                        self.draw_snake.data4 = is_corner;\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Please make the grid 64x64 and snake run twice as fast, and also do a creative job on the background this one is boring",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n\n            fn rot(a: float) -> mat2 {\n                let s = sin(a);\n                let c = cos(a);\n                return mat2(c, -s, s, c);\n            }\n\n            fn hash(p: vec2) -> float {\n                 let q = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n                 return fract(sin(dot(q, vec2(12.9898, 78.233))) * 43758.5453);\n             }\n\n            fn noise(p: vec2) -> float {\n                let i = floor(p);\n                let f = fract(p);\n                let u = f * f * (3.0 - 2.0 * f);\n\n                let h11 = self.hash(i);\n                let h21 = self.hash(i + vec2(1.0, 0.0));\n                let h12 = self.hash(i + vec2(0.0, 1.0));\n                let h22 = self.hash(i + vec2(1.0, 1.0));\n\n                return mix(mix(h11, h21, u.x), mix(h12, h22, u.x), u.y);\n            }\n\n            fn fbm(p: vec2) -> float {\n                 let v = 0.0;\n                 let a = 0.5;\n                 let shift = vec2(100.0, 100.0);\n                 for i in 0..5 {\n                     v = v + a * self.noise(p);\n                     p = p * 2.0 + shift;\n                     a = a * 0.5;\n                 }\n                 return v;\n            }\n\n            fn galaxy(self, p: vec2) -> vec3 {\n                let t = self.time * 0.05;\n                let pp = p * self.rot(t * 0.5);\n                let f = self.fbm(pp * 2.0);\n\n                let angle = atan(p.y, p.x) + f * 2.0;\n                let dist = length(p);\n                let spiral = sin(angle * 5.0 - dist * 5.0 + t * 2.0);\n                let stars = pow(max(0.0, self.noise(p * 100.0 + t)), 30.0) * 0.2;\n\n                let col = vec3(0.1, 0.05, 0.2) + spiral * vec3(0.5, 0.2, 0.7) * (0.5 + 0.5 * sin(dist * 10.0));\n                let col = col + stars;\n                return col;\n            }\n            \n            fn pixel(self)->vec4{\n                let uv = self.pos - 0.5;\n                let zoom = 2.0 - self.food_eaten_factor * 0.5;\n                let p = uv * zoom;\n\n                let col = self.galaxy(p);\n\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = col + vec3(flash_brightness);\n\n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let max_radius = 0.4;\n                let min_radius = 0.1;\n                let fade_factor = self.data1;\n                let current_radius = mix(max_radius, min_radius, fade_factor);\n\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, current_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, current_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((64,64))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.05);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = angle_out; \n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"You have to use fn fbm(self,p:vec2)->float, define 'self' as the first arg on all these functions otherwise it doesnt work",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0,\n        data3: 0.0,\n        data4: 0.0,\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n\n            fn rot(self, a: float) -> mat2 {\n                let s = sin(a);\n                let c = cos(a);\n                return mat2(c, -s, s, c);\n            }\n\n            fn hash(self, p: vec2) -> float {\n                 let q = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n                 return fract(sin(dot(q, vec2(12.9898, 78.233))) * 43758.5453);\n             }\n\n            fn noise(self, p: vec2) -> float {\n                let i = floor(p);\n                let f = fract(p);\n                let u = f * f * (3.0 - 2.0 * f);\n\n                let h11 = self.hash(i);\n                let h21 = self.hash(i + vec2(1.0, 0.0));\n                let h12 = self.hash(i + vec2(0.0, 1.0));\n                let h22 = self.hash(i + vec2(1.0, 1.0));\n\n                return mix(mix(h11, h21, u.x), mix(h12, h22, u.x), u.y);\n            }\n\n            fn fbm(self, p: vec2) -> float {\n                 let v = 0.0;\n                 let a = 0.5;\n                 let shift = vec2(100.0, 100.0);\n                 for i in 0..5 {\n                     v = v + a * self.noise(p);\n                     p = p * 2.0 + shift;\n                     a = a * 0.5;\n                 }\n                 return v;\n            }\n\n            fn galaxy(self, p: vec2) -> vec3 {\n                let t = self.time * 0.05;\n                let pp = p * self.rot(t * 0.5);\n                let f = self.fbm(pp * 2.0);\n\n                let angle = atan(p.y, p.x) + f * 2.0;\n                let dist = length(p);\n                let spiral = sin(angle * 5.0 - dist * 5.0 + t * 2.0);\n                let stars = pow(max(0.0, self.noise(p * 100.0 + t)), 30.0) * 0.2;\n\n                let col = vec3(0.1, 0.05, 0.2) + spiral * vec3(0.5, 0.2, 0.7) * (0.5 + 0.5 * sin(dist * 10.0));\n                let col = col + stars;\n                return col;\n            }\n            \n            fn pixel(self)->vec4{\n                let uv = self.pos - 0.5;\n                let zoom = 2.0 - self.food_eaten_factor * 0.5;\n                let p = uv * zoom;\n\n                let col = self.galaxy(p);\n\n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = col + vec3(flash_brightness);\n\n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let max_radius = 0.4;\n                let min_radius = 0.1;\n                let fade_factor = self.data1;\n                let current_radius = mix(max_radius, min_radius, fade_factor);\n\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, current_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, current_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n    #[live] data3: f32,\n    #[live] data4: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((64,64))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.05);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"Could you make the  background plasma more colourful and the stars look a bit low res maybe use a higher frequency noise and also make it paralax scroll",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0,\n        data3: 0.0,\n        data4: 0.0,\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n\n            fn rot(self, a: float) -> mat2 {\n                let s = sin(a);\n                let c = cos(a);\n                return mat2(c, -s, s, c);\n            }\n            \n            fn hash(self, p: vec2) -> float {\n                 let q = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n                 return fract(sin(dot(q, vec2(12.9898, 78.233))) * 43758.5453);\n            }\n            \n            fn noise(self, p: vec2) -> float {\n                let i = floor(p);\n                let f = fract(p);\n                let u = f * f * (3.0 - 2.0 * f);\n\n                let h11 = self.hash(i);\n                let h21 = self.hash(i + vec2(1.0, 0.0));\n                let h12 = self.hash(i + vec2(0.0, 1.0));\n                let h22 = self.hash(i + vec2(1.0, 1.0));\n\n                return mix(mix(h11, h21, u.x), mix(h12, h22, u.x), u.y);\n            }\n\n            fn fbm(self, p: vec2) -> float {\n                 let v = 0.0;\n                 let a = 0.5;\n                 let shift = vec2(100.0, 100.0);\n                 for i in 0..5 {\n                     v = v + a * self.noise(p);\n                     p = p * 2.0 + shift;\n                     a = a * 0.5;\n                 }\n                 return v;\n            }\n\n            fn swirling_plasma(self, p: vec2) -> vec3 {\n                let t = self.time * 0.1;\n                let scroll_speed = vec2(0.1, 0.05);\n                let p1 = p + scroll_speed * self.time;\n                let p2 = p + vec2(5.2, 1.3) + scroll_speed * self.time * 0.8;\n                let p3 = p + vec2(4.1, 6.3) + scroll_speed * self.time * 1.2;\n                \n                let val = 0.0;\n                val = val + self.fbm(p1 * 1.0 + self.fbm(p1 * 2.0 + t));\n                val = val + self.fbm(p2 * 0.8 + self.fbm(p2 * 1.5 + t * 0.8));\n                val = val + self.fbm(p3 * 1.2 + self.fbm(p3 * 2.5 + t * 1.2));\n                \n                let v = val / 3.0;\n\n                let r = 0.5 + 0.5 * cos(v * 2.0 * PI + 0.0 + t * 2.0);\n                let g = 0.5 + 0.5 * sin(v * 2.0 * PI + 1.0 + t * 2.5);\n                let b = 0.5 + 0.5 * sin(v * 2.0 * PI + 2.0 + t * 3.0);\n                \n                return vec3(r, g, b);\n            }\n            \n            fn stars(self, p: vec2) -> float {\n                let t = self.time * 0.01;\n                let p_high_freq = p * 80.0 + t; \n                let star_noise = self.noise(p_high_freq);\n                let stars = pow(max(0.0, star_noise - 0.8) / 0.2, 6.0);\n                return stars * 0.5;\n            }\n\n            fn pixel(self)->vec4{\n                let uv = self.pos;\n                let parallax_factor = 0.1;\n                let parallax_offset = vec2(self.time * parallax_factor * 0.2, self.time * parallax_factor * 0.1);\n                let p = uv * 3.0 + parallax_offset;\n\n                let plasma_color = self.swirling_plasma(p);\n                let star_intensity = self.stars(uv * 3.0 + parallax_offset * 0.5); // Slower parallax for stars\n\n                let col = plasma_color * 0.8 + star_intensity;\n                \n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = col + vec3(flash_brightness);\n\n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let max_radius = 0.4;\n                let min_radius = 0.1;\n                let fade_factor = self.data1;\n                let current_radius = mix(max_radius, min_radius, fade_factor);\n\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, current_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, current_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((64,64))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.05);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in); \n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"can you make a particle effect that plays when you hit the food centered around the food? Use a custom DrawBlock but don't align the particle blocks to the grid ",
                )),
                Assistant("```rust\n\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawParticle = {{DrawParticle}} {\n        uniform fade: float\n        fn pixel(self)->vec4{\n            let center = vec2(0.5, 0.5);\n            let dist = length(self.pos - center);\n            let alpha = (1.0 - smoothstep(0.0, 0.5, dist)) * self.fade;\n            if alpha < 0.01 {\n                 return vec4(0.0,0.0,0.0,0.0);\n            }\n            return vec4(1.0, 1.0, 0.8, alpha);\n        }\n    }\n\n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg:{\n            uniform food_eaten_factor: float;\n\n            fn rot(self, a: float) -> mat2 {\n                let s = sin(a);\n                let c = cos(a);\n                return mat2(c, -s, s, c);\n            }\n            \n            fn hash(self, p: vec2) -> float {\n                 let q = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n                 return fract(sin(dot(q, vec2(12.9898, 78.233))) * 43758.5453);\n             }\n            \n            fn noise(self, p: vec2) -> float {\n                let i = floor(p);\n                let f = fract(p);\n                let u = f * f * (3.0 - 2.0 * f);\n\n                let h11 = self.hash(i);\n                let h21 = self.hash(i + vec2(1.0, 0.0));\n                let h12 = self.hash(i + vec2(0.0, 1.0));\n                let h22 = self.hash(i + vec2(1.0, 1.0));\n\n                return mix(mix(h11, h21, u.x), mix(h12, h22, u.x), u.y);\n            }\n\n            fn fbm(self, p: vec2) -> float {\n                 let v = 0.0;\n                 let a = 0.5;\n                 let shift = vec2(100.0, 100.0);\n                 for i in 0..5 {\n                     v = v + a * self.noise(p);\n                     p = p * 2.0 + shift;\n                     a = a * 0.5;\n                 }\n                 return v;\n            }\n\n            fn swirling_plasma(self, p: vec2) -> vec3 {\n                let t = self.time * 0.1;\n                let scroll_speed = vec2(0.1, 0.05);\n                let p1 = p + scroll_speed * self.time;\n                let p2 = p + vec2(5.2, 1.3) + scroll_speed * self.time * 0.8;\n                let p3 = p + vec2(4.1, 6.3) + scroll_speed * self.time * 1.2;\n                \n                let val = 0.0;\n                val = val + self.fbm(p1 * 1.0 + self.fbm(p1 * 2.0 + t));\n                val = val + self.fbm(p2 * 0.8 + self.fbm(p2 * 1.5 + t * 0.8));\n                val = val + self.fbm(p3 * 1.2 + self.fbm(p3 * 2.5 + t * 1.2));\n                \n                let v = val / 3.0;\n\n                let r = 0.5 + 0.5 * cos(v * 2.0 * PI + 0.0 + t * 2.0);\n                let g = 0.5 + 0.5 * sin(v * 2.0 * PI + 1.0 + t * 2.5);\n                let b = 0.5 + 0.5 * sin(v * 2.0 * PI + 2.0 + t * 3.0);\n                \n                return vec3(r, g, b);\n            }\n            \n            fn stars(self, p: vec2) -> float {\n                let t = self.time * 0.01;\n                let p_high_freq = p * 80.0 + t; \n                let star_noise = self.noise(p_high_freq);\n                let stars = pow(max(0.0, star_noise - 0.8) / 0.2, 6.0);\n                return stars * 0.5;\n            }\n\n            fn pixel(self)->vec4{\n                let uv = self.pos;\n                let parallax_factor = 0.1;\n                let parallax_offset = vec2(self.time * parallax_factor * 0.2, self.time * parallax_factor * 0.1);\n                let p = uv * 3.0 + parallax_offset;\n\n                let plasma_color = self.swirling_plasma(p);\n                let star_intensity = self.stars(uv * 3.0 + parallax_offset * 0.5); // Slower parallax for stars\n\n                let col = plasma_color * 0.8 + star_intensity;\n                \n                let flash_brightness = self.food_eaten_factor * 0.8;\n                let final_color = col + vec3(flash_brightness);\n\n                return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n            }\n        }\n                \n        draw_snake:{\n                        \n            fn sdf_capsule( self, p: vec2, a: vec2, b: vec2, r: float ) -> float{\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                return length( pa - ba*h ) - r;\n            }\n            \n            fn capsule_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_capsule(p, a, b, r);\n                let grad_x = self.sdf_capsule(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_capsule(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                                \n                let max_radius = 0.4;\n                let min_radius = 0.1;\n                let fade_factor = self.data1;\n                let current_radius = mix(max_radius, min_radius, fade_factor);\n\n                let half_length = 0.5;\n                let center = vec2(0.5, 0.5);\n                                \n                let angle_rad = self.data2; \n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                                \n                let a = center - dir_vec * half_length;\n                let b = center + dir_vec * half_length;\n                \n                let dist = self.sdf_capsule(p, a, b, current_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.capsule_normal(p, a, b, current_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0); \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    return vec4(0.0, 0.0, 0.0, 0.0);\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0)); \n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawParticle {\n    #[deref] draw_super: DrawQuad,\n    #[live] fade: f32,\n}\n\n#[derive(Clone)]\npub struct Particle {\n    pos: DVec2,\n    vel: DVec2,\n    creation_time: Instant,\n    max_age: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\nconst FLASH_DURATION: f32 = 0.7;\nconst PARTICLE_LIFESPAN: f32 = 0.5;\nconst NUM_PARTICLES: usize = 20;\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n    #[live] draw_particle: DrawParticle,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((64,64))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] restart_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(Instant::now())] last_food_eaten_time: Instant,\n    #[rust] food_eaten_factor: f32,\n    #[rust(0u64)] rng_state: u64,\n    #[rust] particles: Vec<Particle>,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n\n    fn random_float(&mut self) -> f64 {\n        self.simple_rng() as f64 / std::u64::MAX as f64\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                self.last_food_place_time = Instant::now();\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx, bg_rect: Rect, cell_size: DVec2){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n        let mut food_coord = (0,0);\n\n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                cx.stop_timer(self.game_timer);\n                self.restart_timer = cx.start_timeout(2.0);\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                food_coord = (next_x, next_y);\n                self.food_eaten_factor = 1.0;\n                self.last_food_eaten_time = Instant::now();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {} \n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        } else {\n            let center_pos = bg_rect.pos + dvec2(food_coord.0 as f64 * cell_size.x + cell_size.x * 0.5, food_coord.1 as f64 * cell_size.y + cell_size.y * 0.5);\n            for _ in 0..NUM_PARTICLES {\n                let angle = self.random_float() * 2.0 * PI as f64;\n                let speed = self.random_float() * 50.0 + 20.0;\n                let vel = dvec2(angle.cos() * speed, angle.sin() * speed);\n                self.particles.push(Particle{\n                    pos: center_pos,\n                    vel: vel,\n                    creation_time: Instant::now(),\n                    max_age: PARTICLE_LIFESPAN * (0.5 + self.random_float() as f32 * 0.5)\n                });\n            }\n        }\n        \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self, cx: &mut Cx) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n        self.particles.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = 0;\n        \n        self.place_food(); \n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.food_eaten_factor = 0.0;\n        self.last_food_eaten_time = Instant::now() - std::time::Duration::from_secs_f32(FLASH_DURATION); \n        self.game_timer = cx.start_interval(0.05);\n        \n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game(cx);\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        if self.food_eaten_factor > 0.0 {\n            let time_now = Instant::now();\n            let time_since_eaten = time_now.duration_since(self.last_food_eaten_time).as_secs_f32();\n            if time_since_eaten < FLASH_DURATION {\n                self.food_eaten_factor = (1.0 - time_since_eaten / FLASH_DURATION).powf(2.0);\n            }\n            else{\n                self.food_eaten_factor = 0.0;\n            }\n        }\n        \n        self.draw_bg.set_uniform(cx, id!(food_eaten_factor), &[self.food_eaten_factor]);\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 { \n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in); \n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad; \n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n\n        let time_now = Instant::now();\n        let mut i = 0;\n        while i < self.particles.len() {\n             let particle = &mut self.particles[i];\n             let age = time_now.duration_since(particle.creation_time).as_secs_f32();\n             if age >= particle.max_age {\n                 self.particles.remove(i);\n             } else {\n                 particle.pos += particle.vel * 0.016; // Assuming roughly 60fps for velocity update\n                 let fade = (1.0 - age / particle.max_age).powf(0.5);\n                 self.draw_particle.fade = fade;\n                 let particle_size = 10.0 + fade as f64 * 15.0;\n                 let particle_rect = Rect {\n                     pos: particle.pos - dvec2(particle_size*0.5, particle_size*0.5),\n                     size: dvec2(particle_size, particle_size)\n                 };\n                 self.draw_particle.draw_abs(cx, particle_rect);\n                 i += 1;\n             }\n        }\n\n        self.draw_bg.end(cx);\n        if self.food_eaten_factor > 0.0 || self.game_over || !self.particles.is_empty() {\n            cx.redraw_area_in_draw(self.draw_bg.area());\n        }\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n         let bg_rect = self.draw_bg.area().get_rect(cx);\n         let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n         let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n         let cell_size = dvec2(cell_w, cell_h);\n\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx, bg_rect, cell_size);\n        }\n\n        if self.restart_timer.is_event(event).is_some(){\n            self.restart_game(cx);\n            self.redraw(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    cx.stop_timer(self.restart_timer);\n                    self.restart_game(cx);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App); \n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) { \n        makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"",
                )),
            ],
        ),
        (
            context:[
            ],
            auto_run:true,
            model:"gemini 2.5 pro",
            project:"makepad-experiment-ai-one",
            base_context:"Makepad Game",
            last_time:1746181611.43392,
            messages:[
                User((
                    message:"The blocks arent tubes that are connected at the edges, they have round edges now. Please try to make a tube in the shader that gets cut off at the edges so the snake connects properly. Also could you animate the background when the snake gets a piece of food so it crinkles the shapes/flashes a bit?",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n\n    DrawBlock = {{DrawBlock}}{\n        fn pixel(self) -> vec4 {\n            let center = vec2(0.5, 0.5);\n            let radius = 0.45;\n            let dist = distance(self.pos, center);\n            let AA = self.get_antialias_blur_radius();\n            let alpha = 1.0 - smoothstep(radius - AA, radius + AA, dist);\n            let color = mix(#33ff33, #33ff00, self.data1);\n            return vec4(color.rgb * alpha, alpha);\n        }\n    }\n\n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n        draw_bg:{\n            food_eaten_time: float,\n            fn random_noise(self, p: vec2) -> float {\n                 return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n            }\n            fn pixel(self)->vec4{\n                let base_color = #113311;\n                let flash_intensity = self.food_eaten_time * self.food_eaten_time;\n                let flash_color = mix(base_color.rgb, vec3(1.0, 1.0, 0.8), flash_intensity * 0.5);\n                \n                let noise_val = self.random_noise(self.pos * 20.0 + self.time * 0.5);\n                let crinkle_effect = flash_intensity * noise_val * 0.1;\n\n                return vec4(flash_color + crinkle_effect, 1.0);\n            }\n        }\n        draw_snake: DrawBlock {}\n        draw_head:{\n             fn pixel(self)->vec4{\n                 return #66ffff;\n             }\n        }\n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n        draw_food: {\n            fn pixel(self) -> vec4 {\n                return #ffff00;\n            }\n        }\n    }\n\n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawQuad,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n\n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust(Instant::now())] last_food_place_time: Instant,\n    #[rust(0u64)] rng_state: u64,\n    #[live] #[rust(0.0)] food_eaten_time: f32,\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n    }\n    \n    fn after_apply(&mut self, cx: &mut Cx, apply: &mut Apply, index: usize, nodes: &[LiveNode]) {\n        if apply.from.is_from_doc() && nodes[index].is_instance(live_id!(SnakeGame)) {\n             self.draw_bg.apply_over(cx, nodes);\n        }\n    }\n}\n\nimpl SnakeGame{\n\n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n\n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n\n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n\n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n\n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n\n        let next_idx = next_y * grid_w + next_x;\n\n        let mut ate_food = false;\n\n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n                self.food_eaten_time = 1.0;\n                cx.request_next_frame();\n                self.place_food();\n            }\n            Field::Empty | Field::Head => {}\n        }\n\n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n\n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n\n        if !ate_food {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                     self.snake_body.push_back(tail);\n                }\n            }\n        }\n\n        self.redraw(cx);\n    }\n\n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n\n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n\n        self.rng_state = Instant::now().elapsed().as_nanos() as u64;\n        if self.rng_state == 0 { self.rng_state = 1; }\n\n        self.place_food();\n\n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_place_time = Instant::now();\n        self.food_eaten_time = 0.0;\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        self.draw_bg.set_uniform(cx, live_id!(food_eaten_time), &[self.food_eaten_time]);\n        self.draw_bg.begin(cx, walk, self.layout);\n        \n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n\n        let snake_len = self.snake_body.len();\n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field_index = y * self.grid_size.0 + x;\n                let field = &self.field[field_index];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut data1 = 0.0;\n                        if let Some(pos_in_body) = self.snake_body.iter().position(|&p| p == (x,y)) {\n                           data1 = pos_in_body as f32 / snake_len as f32;\n                        }\n                        self.draw_snake.data1 = data1;\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n\n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if let Event::NextFrame(nfe) = event {\n            if self.food_eaten_time > 0.0 {\n                let time_passed = nfe.time - nfe.last_time;\n                self.food_eaten_time -= (time_passed * 2.0) as f32; // Fades over ~0.5 sec\n                self.food_eaten_time = self.food_eaten_time.max(0.0);\n                self.redraw(cx);\n                if self.food_eaten_time > 0.0 {\n                    cx.request_next_frame();\n                }\n            }\n        }\n\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n\n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            Hit::KeyDown(ke) => {\n                if self.game_over && ke.key_code == KeyCode::Space {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                } else if !self.game_over {\n                    let current_dir = self.snake_direction;\n                    match ke.key_code {\n                        KeyCode::ArrowUp | KeyCode::KeyW if current_dir != (0, 1) => {\n                            self.snake_direction = (0,-1);\n                        }\n                        KeyCode::ArrowDown | KeyCode::KeyS if current_dir != (0, -1) => {\n                            self.snake_direction = (0,1);\n                        }\n                        KeyCode::ArrowLeft | KeyCode::KeyA if current_dir != (1, 0) => {\n                            self.snake_direction = (-1,0);\n                        }\n                        KeyCode::ArrowRight | KeyCode::KeyD if current_dir != (-1, 0) => {\n                            self.snake_direction = (1,0);\n                        }\n                        _=>()\n                    }\n                }\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App);\n\n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n\nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) {\n        crate::makepad_widgets::live_design(cx);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"",
                )),
            ],
        ),
        (
            context:[
            ],
            auto_run:true,
            model:"gemini 2.5 pro",
            project:"makepad-experiment-ai-one",
            base_context:"Makepad Game",
            last_time:1746181876.606661,
            messages:[
                User((
                    message:"The blocks arent tubes that are connected at the edges, they have round edges now. Please try to make a tube in the shader that gets cut off at the edges so the snake connects properly. Also could you animate the background when the snake gets a piece of food so it crinkles the shapes/flashes a bit? Please use a new shader like DrawBlock but for DrawBg and input the data via the struct to the shader",
                )),
                Assistant("```rust\nuse makepad_widgets::*;\nuse std::collections::VecDeque;\nuse std::time::Instant;\nuse std::cmp::Ordering;\nuse std::f32::consts::PI;\n\nlive_design!{\n    use link::widgets::*;\n    use link::theme::*;\n    use link::shaders::*;\n        \n    DrawBlock = {{DrawBlock}}{\n        data1: 0.0,\n        data2: 0.0\n    }\n\n    DrawBgBlock = {{DrawBgBlock}}{\n        food_anim_phase: 100.0,\n        \n        fn plasma_height(self, p: vec2) -> float {\n            let v = 0.0;\n            let anim_intensity = max(0.0, 1.0 - self.food_anim_phase) * sin(self.food_anim_phase * 20.0) * 0.2;\n            let p_anim = p + vec2(anim_intensity, anim_intensity);\n            \n            v = v + sin((p_anim.x * 1.5 + self.time) * 2.0);\n            v = v + sin((p_anim.y * 1.0 + self.time * 0.5) * 3.0);\n            v = v + sin((p_anim.x * 0.8 + p_anim.y * 1.2 + self.time * 0.8) * 1.0);\n            v = v + sin(sqrt(p_anim.x * p_anim.x + p_anim.y * p_anim.y) * 2.5 + self.time * 1.2);\n            return v / 4.0;\n        }\n        \n        fn plasma_normal(self, p: vec2) -> vec3 {\n            let epsilon = 0.005;\n            let h = self.plasma_height(p);\n            let hx = self.plasma_height(p + vec2(epsilon, 0.0));\n            let hy = self.plasma_height(p + vec2(0.0, epsilon));\n            let n = normalize(vec3(h - hx, h - hy, epsilon * 2.0));\n            return n;\n        }\n        \n        fn pastel_color(self, v: float) -> vec3 {\n            let pi = 3.1415926535;\n            let r = 0.8 + 0.2 * sin(pi * v);\n            let g = 0.8 + 0.2 * sin(pi * v + 2.0 * pi / 3.0);\n            let b = 0.8 + 0.2 * sin(pi * v + 4.0 * pi / 3.0);\n            return vec3(r, g, b);\n        }\n        \n        fn pixel(self)->vec4{\n            let p = self.pos * 8.0;\n            let height = self.plasma_height(p);\n            let normal = self.plasma_normal(p);\n            let light_dir = normalize(vec3(0.7, 0.6, 0.4));\n                            \n            let diffuse = max(0.0, dot(normal, light_dir));\n            let bump_factor = pow(diffuse, 4.0);\n                            \n            let base_color = self.pastel_color(height);\n            \n            let flash_intensity = max(0.0, 1.0 - self.food_anim_phase) * 0.5;\n            let final_color = base_color * (0.3 + bump_factor * 1.5) + vec3(flash_intensity);\n                            \n            return vec4(clamp(final_color, 0.0, 1.0), 1.0);\n        }\n    }\n        \n    SnakeGame = {{SnakeGame}}{\n        width: Fill,\n        height: Fill,\n                \n        draw_bg: <DrawBgBlock>{}\n                \n        draw_snake:{\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2, r: float) -> float {\n                 let pa = p - a;\n                 let ba = b - a;\n                 let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                 return length( pa - ba*h ) - r;\n            }\n            \n            fn line_normal(self, p: vec2, a: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.001;\n                let dist = self.sdf_line(p, a, b, r);\n                let grad_x = self.sdf_line(p + vec2(epsilon, 0.0), a, b, r) - dist;\n                let grad_y = self.sdf_line(p + vec2(0.0, epsilon), a, b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                let proj_p_on_line = a + ba*h;\n                if dot(p - proj_p_on_line, n2) < 0.0 {\n                     // this should not happen with sdf gradient but check anyway\n                     //n2 = -n2;\n                }\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                                \n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0);\n                                \n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let tube_radius = 0.4;\n                let center = vec2(0.5, 0.5);\n                \n                let angle_rad = self.data2;\n                let dir_vec = vec2(cos(angle_rad), sin(angle_rad));\n                \n                let a = center - dir_vec * 0.7;\n                let b = center + dir_vec * 0.7;\n                \n                let dist = self.sdf_line(p, a, b, tube_radius);\n                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    discard;\n                }\n                \n                let normal = self.line_normal(p, a, b, tube_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0));\n                                \n                let base_angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(base_angle), sin(base_angle), 0.8));\n                                \n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                \n                let color1 = vec3(0.2, 1.0, 0.2);\n                let color2 = vec3(0.2, 0.6, 0.0);\n                let fade_factor = self.data1;\n                let albedo = mix(color1, color2, fade_factor);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n                \n        draw_head:{\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n                        \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n            \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0);\n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n            \n            fn sdf_line(self, p: vec2, a: vec2, b: vec2) -> float {\n                let pa = p - a;\n                let ba = b - a;\n                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n                return length(pa - ba * h);\n            }\n            \n            fn sdf_circle(self, p: vec2, center: vec2, radius: float) -> float {\n                return length(p - center) - radius;\n            }\n            \n            fn pixel(self)->vec4{\n                let p = self.pos;\n                let box_half_size = vec2(0.48, 0.48);\n                let corner_radius = 0.15;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    discard;\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0));\n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.1);\n                let specular_power = 32.0;\n                let albedo = vec3(0.4, 1.0, 1.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                let eye1_pos = vec2(0.35, 0.4);\n                let eye2_pos = vec2(0.65, 0.4);\n                let eye_radius = 0.08;\n                let eye_dist1 = self.sdf_circle(p, eye1_pos, eye_radius);\n                let eye_dist2 = self.sdf_circle(p, eye2_pos, eye_radius);\n                                \n                let smile_start = vec2(0.3, 0.65);\n                let smile_end = vec2(0.7, 0.65);\n                let smile_dist = self.sdf_line(p, smile_start, smile_end);\n                let smile_thickness = 0.03;\n                \n                let eye_mask = min(smoothstep(0.01, 0.0, eye_dist1), smoothstep(0.01, 0.0, eye_dist2));\n                let smile_mask = smoothstep(smile_thickness + 0.01, smile_thickness, smile_dist);\n                \n                let final_color = mix(shaded_color, vec3(0.0, 0.0, 0.0), eye_mask);\n                let final_color_with_smile = mix(final_color, vec3(0.0, 0.0, 0.0), smile_mask);\n                \n                return vec4(final_color_with_smile, alpha);\n            }\n        }\n                \n        draw_wall: {\n            fn pixel(self) -> vec4 {\n                return #ff0000;\n            }\n        }\n                \n        draw_food: {\n            fn sdf_rounded_box(self, p: vec2, b: vec2, r: float) -> float {\n                let center = vec2(0.5, 0.5);\n                let q = abs(p - center) - b + r;\n                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n            }\n            \n            fn rounded_box_normal(self, p: vec2, b: vec2, r: float) -> vec3 {\n                let epsilon = 0.0001;\n                let dist = self.sdf_rounded_box(p, b, r);\n                let grad_x = self.sdf_rounded_box(p + vec2(epsilon, 0.0), b, r) - dist;\n                let grad_y = self.sdf_rounded_box(p + vec2(0.0, epsilon), b, r) - dist;\n                let n2 = normalize(vec2(grad_x, grad_y));\n                let z = sqrt(max(0.0, 1.0 - dot(n2, n2)));\n                return normalize(vec3(n2.x, n2.y, z));\n            }\n                         \n            fn phong_lighting(self, normal: vec3, view_dir: vec3, light_dir: vec3, albedo: vec3, ambient: vec3, specular_power: float) -> vec3 {\n                let diffuse_intensity = max(dot(normal, light_dir), 0.0);\n                let diffuse = diffuse_intensity * albedo;\n                let reflect_dir = reflect(-light_dir, normal);\n                let spec_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), specular_power);\n                let specular = spec_intensity * vec3(1.0, 1.0, 1.0);\n                let final_color = ambient + diffuse + specular;\n                return final_color;\n            }\n                        \n            fn pixel(self) -> vec4 {\n                let p = self.pos;\n                let box_half_size = vec2(0.4, 0.4);\n                let corner_radius = 0.2;\n                let dist = self.sdf_rounded_box(p, box_half_size, corner_radius);\n                                \n                let alpha = smoothstep(0.02, 0.0, dist);\n                if alpha < 0.01 {\n                    discard;\n                }\n                \n                let normal = self.rounded_box_normal(p, box_half_size, corner_radius);\n                let view_dir = normalize(vec3(0.0, 0.0, 1.0));\n                let angle = self.time * 0.5;\n                let light_dir = normalize(vec3(cos(angle), sin(angle), 0.8));\n                let ambient = vec3(0.1, 0.1, 0.0);\n                let specular_power = 32.0;\n                let albedo = vec3(1.0, 1.0, 0.0);\n                \n                let shaded_color = self.phong_lighting(normal, view_dir, light_dir, albedo, ambient, specular_power);\n                \n                return vec4(shaded_color, alpha);\n            }\n        }\n    }\n                \n    App = {{App}} {\n        ui: <Root>{\n            main_window = <Window>{\n                window: {inner_size: vec2(800, 600)},\n                body = <View>{\n                    show_bg: true,\n                    flow: Down,\n                    game = <SnakeGame>{}\n                }\n            }\n        }\n    }\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] data1: f32,\n    #[live] data2: f32,\n}\n\n#[derive(Live, LiveHook, LiveRegister)]\n#[repr(C)]\npub struct DrawBgBlock {\n    #[deref] draw_super: DrawQuad,\n    #[live] food_anim_phase: f32,\n}\n\n#[derive(Clone, PartialEq)]\npub enum Field{\n    Empty,\n    Wall,\n    Snake,\n    Head,\n    Food,\n}\n\n#[derive(Live, Widget)]\nstruct SnakeGame{\n    #[layout] layout: Layout,\n    #[walk] walk: Walk,\n    #[redraw] #[live] draw_bg: DrawBgBlock,\n    #[live] draw_wall: DrawQuad,\n    #[live] draw_snake: DrawBlock,\n    #[live] draw_head: DrawQuad,\n    #[live] draw_food: DrawQuad,\n                \n    #[rust] field: Vec<Field>,\n    #[rust] snake_body: VecDeque<(usize, usize)>,\n    #[rust] snake_head: (usize, usize),\n    #[rust] snake_direction: (isize, isize),\n    #[rust((32,32))] grid_size: (usize, usize),\n    #[rust] game_timer: Timer,\n    #[rust] game_over: bool,\n    #[rust] last_food_eaten_time: Option<f64>,\n    #[rust(0u64)] rng_state: u64,\n}\n\nimpl SnakeGame{\n        \n    fn simple_rng(&mut self) -> u64 {\n        self.rng_state = self.rng_state.wrapping_add(0xdeadbeefdeadbeef);\n        let mut x = self.rng_state;\n        x ^= x >> 12;\n        x ^= x << 25;\n        x ^= x >> 27;\n        self.rng_state = x;\n        return x.wrapping_mul(0x2545F4914F6CDD1D);\n    }\n        \n    fn place_food(&mut self){\n        let (grid_w, grid_h) = self.grid_size;\n        let max_attempts = grid_w * grid_h;\n        for _ in 0..max_attempts {\n            let rand_val = self.simple_rng();\n            let x = (rand_val % grid_w as u64) as usize;\n            let y = ((rand_val / grid_w as u64) % grid_h as u64) as usize;\n            let idx = y * grid_w + x;\n            if self.field[idx] == Field::Empty {\n                self.field[idx] = Field::Food;\n                return;\n            }\n        }\n    }\n    \n    fn find_food_pos(&self) -> Option<(usize, usize)> {\n        let (grid_w, _) = self.grid_size;\n        self.field.iter().position(|f| *f == Field::Food).map(|idx| (idx % grid_w, idx / grid_w))\n    }\n    \n    fn manhattan_distance(p1: (usize, usize), p2: (usize, usize)) -> usize {\n        ((p1.0 as isize - p2.0 as isize).abs() + (p1.1 as isize - p2.1 as isize).abs()) as usize\n    }\n    \n    fn determine_next_direction(&mut self) {\n        if self.game_over { return; }\n        \n        let food_pos_opt = self.find_food_pos();\n        if food_pos_opt.is_none() { return; }\n        let food_pos = food_pos_opt.unwrap();\n        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let current_dir = self.snake_direction;\n        \n        let potential_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)];\n        let mut valid_moves = Vec::new();\n        \n        for dir in potential_dirs {\n            if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                if self.snake_body.len() > 1 { continue; }\n            }\n            \n            let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n            let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n            let next_idx = next_y * grid_w + next_x;\n            \n            match self.field[next_idx] {\n                Field::Empty | Field::Food => {\n                    let distance = Self::manhattan_distance((next_x, next_y), food_pos);\n                    valid_moves.push((dir, distance));\n                }\n                _ => {}\n            }\n        }\n        \n        if let Some(best_move) = valid_moves.iter().min_by_key(|(_, dist)| *dist) {\n            self.snake_direction = best_move.0;\n        } else {\n            for dir in potential_dirs {\n                if dir.0 == -current_dir.0 && dir.1 == -current_dir.1 {\n                    if self.snake_body.len() > 1 { continue; }\n                }\n                let next_x = (head_x as isize + dir.0 + grid_w as isize) as usize % grid_w;\n                let next_y = (head_y as isize + dir.1 + grid_h as isize) as usize % grid_h;\n                let next_idx = next_y * grid_w + next_x;\n                match self.field[next_idx] {\n                    Field::Empty | Field::Food => {\n                        self.snake_direction = dir;\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n        \n    fn next_tick(&mut self, cx: &mut Cx){\n        if self.game_over {\n            return;\n        }\n        \n        self.determine_next_direction();\n                        \n        let (grid_w, grid_h) = self.grid_size;\n        let (head_x, head_y) = self.snake_head;\n        let (dir_x, dir_y) = self.snake_direction;\n                        \n        let next_x = (head_x as isize + dir_x + grid_w as isize) as usize % grid_w;\n        let next_y = (head_y as isize + dir_y + grid_h as isize) as usize % grid_h;\n                        \n        let next_idx = next_y * grid_w + next_x;\n                        \n        let mut ate_food = false;\n                \n        match self.field[next_idx] {\n            Field::Wall | Field::Snake => {\n                self.game_over = true;\n                self.redraw(cx);\n                return;\n            }\n            Field::Food => {\n                ate_food = true;\n            }\n            Field::Empty | Field::Head => {}\n        }\n                \n        let old_head_idx = head_y * grid_w + head_x;\n        self.field[old_head_idx] = Field::Snake;\n                        \n        self.snake_head = (next_x, next_y);\n        self.snake_body.push_front(self.snake_head);\n        self.field[next_idx] = Field::Head;\n                        \n        if ate_food {\n            self.place_food();\n            self.last_food_eaten_time = Some(cx.time());\n        } else {\n            if let Some(tail) = self.snake_body.pop_back() {\n                if tail != self.snake_head {\n                    let tail_idx = tail.1 * grid_w + tail.0;\n                    if self.field[tail_idx] != Field::Head {\n                        self.field[tail_idx] = Field::Empty;\n                    }\n                } else {\n                    self.snake_body.push_back(tail);\n                }\n            }\n        }\n                \n        self.redraw(cx);\n    }\n            \n    fn restart_game(&mut self) {\n        self.field.clear();\n        self.field.resize(self.grid_size.0 * self.grid_size.1, Field::Empty);\n        self.snake_body.clear();\n                        \n        self.snake_head = (self.grid_size.0 / 2, self.grid_size.1 / 2);\n        self.snake_body.push_front(self.snake_head);\n        let head_idx = self.snake_head.1 * self.grid_size.0 + self.snake_head.0;\n        self.field[head_idx] = Field::Head;\n                        \n        self.rng_state = std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap_or_default()\n        .as_nanos() as u64;\n        \n        self.place_food();\n                        \n        self.snake_direction = (1, 0);\n        self.game_over = false;\n        self.last_food_eaten_time = None;\n    }\n        \n    fn angle_diff(a1: f32, a2: f32) -> f32 {\n        let mut diff = a1 - a2;\n        while diff <= -PI { diff += 2.0 * PI; }\n        while diff > PI { diff -= 2.0 * PI; }\n        return diff;\n    }\n    \n    fn average_angle(a1: f32, a2: f32) -> f32 {\n        let diff = Self::angle_diff(a1, a2);\n        let avg = a2 + diff * 0.5;\n        return avg.rem_euclid(2.0 * PI);\n    }\n}\n\nimpl LiveHook for SnakeGame{\n    fn after_new_from_doc(&mut self, cx:&mut Cx){\n        self.restart_game();\n        self.game_timer = cx.start_interval(0.1);\n        self.last_food_eaten_time = None;\n    }\n}\n\nimpl Widget for SnakeGame{\n    fn draw_walk(&mut self, cx:&mut Cx2d, _scope:&mut Scope, walk:Walk)->DrawStep{\n        \n        let mut food_anim_phase = 100.0;\n        if let Some(eat_time) = self.last_food_eaten_time {\n            let time_since_eaten = cx.time() - eat_time;\n            let anim_duration = 0.5;\n            if time_since_eaten < anim_duration {\n                food_anim_phase = (time_since_eaten / anim_duration) as f32;\n            } else {\n                self.last_food_eaten_time = None;\n            }\n        }\n        self.draw_bg.food_anim_phase = food_anim_phase;\n\n        self.draw_bg.begin(cx, walk, self.layout);\n        let bg_rect = cx.turtle().rect();\n        let cell_w = bg_rect.size.x / self.grid_size.0 as f64;\n        let cell_h = bg_rect.size.y / self.grid_size.1 as f64;\n        let cell_size = dvec2(cell_w, cell_h);\n                        \n        let snake_len = self.snake_body.len();\n        \n        for y in 0..self.grid_size.1{\n            for x in 0..self.grid_size.0{\n                let field = &self.field[y * self.grid_size.0 + x];\n                let rect = Rect{\n                    pos: bg_rect.pos + dvec2(x as f64 * cell_w, y as f64 * cell_h),\n                    size: cell_size\n                };\n                match field{\n                    Field::Empty => {}\n                    Field::Snake => {\n                        let mut fade_factor = 0.0;\n                        let mut segment_angle_rad = 0.0f32;\n                                                \n                        if let Some(index) = self.snake_body.iter().position(|&pos| pos == (x,y)) {\n                            if snake_len > 1 && index > 0 {\n                                fade_factor = (index - 1) as f32 / ((snake_len - 1) as f32).max(1.0);\n                            }\n                            \n                            let next_pos = if index > 0 {\n                                self.snake_body.get(index - 1).unwrap_or(&self.snake_head)\n                            } else {\n                                &self.snake_head\n                            };\n                                                         \n                            let current_pos = (x, y);\n                            \n                            let dx_out = next_pos.0 as f32 - current_pos.0 as f32;\n                            let dy_out = next_pos.1 as f32 - current_pos.1 as f32;\n                            let angle_out = dy_out.atan2(dx_out);\n                            \n                            if index < snake_len - 1 {\n                                let prev_pos = self.snake_body.get(index + 1).unwrap();\n                                let dx_in = current_pos.0 as f32 - prev_pos.0 as f32;\n                                let dy_in = current_pos.1 as f32 - prev_pos.1 as f32;\n                                let angle_in = dy_in.atan2(dx_in);\n                                                                \n                                if (Self::angle_diff(angle_in, angle_out)).abs() > 0.1 {\n                                    segment_angle_rad = Self::average_angle(angle_out, angle_in);\n                                } else {\n                                    segment_angle_rad = angle_out;\n                                }\n                            } else {\n                                segment_angle_rad = angle_out;\n                            }\n                        }\n                                                \n                        self.draw_snake.data1 = fade_factor.max(0.0).min(1.0);\n                        self.draw_snake.data2 = segment_angle_rad;\n                        self.draw_snake.draw_abs(cx, rect);\n                    }\n                    Field::Head => {\n                        self.draw_head.draw_abs(cx, rect);\n                    }\n                    Field::Wall => {\n                        self.draw_wall.draw_abs(cx, rect);\n                    }\n                    Field::Food => {\n                        self.draw_food.draw_abs(cx, rect);\n                    }\n                }\n            }\n        }\n        self.draw_bg.end(cx);\n        DrawStep::done()\n    }\n                \n    fn handle_event(&mut self, cx:&mut Cx, event:&Event, _scope:&mut Scope){\n        if self.game_timer.is_event(event).is_some(){\n            self.next_tick(cx);\n        }\n                        \n        match event{\n            Event::KeyDown(ke) => {\n                if ke.key_code == KeyCode::Space && self.game_over {\n                    self.restart_game();\n                    self.game_timer = cx.start_interval(0.1);\n                    self.redraw(cx);\n                }\n            }\n            _=>()\n        }\n        \n        match event.hits(cx, self.draw_bg.area()){\n            Hit::FingerDown(_fd)=>{\n                cx.set_key_focus(self.draw_bg.area());\n            }\n            _=>()\n        }\n    }\n}\n\napp_main!(App);\n \n#[derive(Live, LiveHook)]\npub struct App {\n    #[live] ui: WidgetRef,\n}\n \nimpl LiveRegister for App {\n    fn live_register(cx: &mut Cx) {\n        makepad_widgets::live_design(cx);\n        \n    }\n}\n \nimpl LiveRegister for SnakeGame{\n    fn live_register(cx:&mut Cx){\n        register_widget!(cx, SnakeGame)\n    }\n}\n\nimpl LiveRegister for DrawBlock {\n    fn live_register(cx: &mut Cx) {\n        register_component!(cx, DrawBlock);\n    }\n}\n\nimpl LiveRegister for DrawBgBlock {\n    fn live_register(cx: &mut Cx) {\n        register_component!(cx, DrawBgBlock);\n    }\n}\n\nimpl AppMain for App {\n    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {\n        self.ui.handle_event(cx, event, &mut Scope::empty());\n    }\n}\n\n```"),
                User((
                    message:"",
                )),
            ],
        ),
    ],
)